
<一>pomelo中不同职责服务器的划分:

1.客户端通过websocket长连接连到connector服务器群。

2.connector负责承载连接，并把请求转发到后端的服务器群。

3.后端的服务器群主要包括按场景分区的场景服务器(area)、聊天服务器(chat)和状态服务器等(status)， 
这些服务器负责各自的业务逻辑。真实的案例中还会有各种其它类型的服务器。

4.后端服务器处理完逻辑后把结果返回给connector， 再由connector广播回给客户端。

5.master负责统一管理这些服务器，包括各服务器的启动、监控和关闭等功能。


而游戏则是基于场景(area)的分区模式， 这使同场景的玩家跑在一个进程内， 以达到最少的跨进程调用。

<二>前端服务器frontend 和 后端服务器backend 的职责
1.前端服务器(frontend)的职责：->

负责承载客户端请求的连接
维护session信息
把请求转发到后端
把后端需要广播的消息发到前端

2.后端服务器(backend)的职责：->

处理业务逻辑， 包括RPC和前端请求的逻辑
把消息推送回前端

<三>新增服务器的鸭子类型
1.handler -> 负责接收客户端的请求

2.remote  -> 接收RPC请求

因此：只需要在handler和remote里面填写代码，就实现了这类服务器。 如chat服务器，area服务器.
     配置好server.json，就可以让服务器快速使用起来.

<四>客户端请求与响应  服务器广播机制

1.客户端发起请求:
pomelo.request('chat.chatHandler.send', {msg: 'hello'}, function(res){
    //这是得到服务端响应后，接下来做的处理
    var result = res.data;
});   

2.服务器端响应
handler.send = function(req, session, next){
    //选择广播还是向指定用户发送信息
} 

<五>rpc接口调用
remote下定义了一个接口：
chatRemote.kick = function(uid, player, cd){

}

其它服务器(rpc客户端)这样可以调用这个接口:

app.rpc.chat.chatRemote.kick(session, uid, player, function(data){

});

这个rpc调用会根据特定的路由规则转发到特定的服务器. (如场景服务根据玩家在哪个场景直接转发到对应的server)

rpc底层框架目前在底层采用的是socket.io通讯协议。 也就是依然是socket


